use crate::ast::{
    PropertyModifier, ASTDeclaration, ASTDeclarationKind, GenericIdentifier, ElementDeffinition, ElementDeffinitionKind,
    ASTExpression, ASTExpressionKind, Operator, ElementExpression, ElementValue, TypedName, ASTStatment, ASTStatmentKind,
    Span
};

use std::str::FromStr;

grammar;

FUNC: () = "func";
COMPONENT: () = "component";
INHERITS: () = "inherits";
PUB: () = "pub";
PROP: () = "prop";
CHILDREN: () = "children";
PARENT: () = "parent";
VAR: () = "var";
MUT: () = "mut";

LBRACE: () = "{";
RBRACE: () = "}";
LPAREN: () = "(";
RPAREN: () = ")";
SEMI: () = ";";
LT: () = "<";
GT: () = ">";
EQ: () = "=";
COLON: () = ":";
COMMA: () = ",";

PLUS: () = "+";
SUB: () = "-";
STAR: () = "*";
SLASH: () = "/";
ARROW: () = "->";
FATARROW: () = "=>";

NumLit: i32 = <s:r"[0-9]+"> => i32::from_str(s).unwrap();
FloatLit: f32 = <s:r"[0-9]+\.[0-9]+"> => f32::from_str(s).unwrap();
Identifier: String = r"[a-zA-Z_][a-zA-Z0-9_]*" => String::from(<>);

ExprOp: Operator = { // (3)
    PLUS => Operator::Add,
    SUB  => Operator::Sub,
};

FactorOp: Operator= {
    STAR => Operator::Star,
    SLASH => Operator::Slash
};

Expression:ASTExpression = {
    <start:@L> <lhs:Expression> <op:ExprOp> <rhs:Factor> <end:@R>=> ASTExpression{
        kind: ASTExpressionKind::Binary{lhs:Box::new(lhs), op, rhs: Box::new(rhs)},
        span:Span {start,end}
    },
    Factor
}
Factor:ASTExpression = {
    <start:@L> <lhs:Factor> <op:FactorOp> <rhs:Term> <end:@R>=> ASTExpression{
        kind:ASTExpressionKind::Binary{lhs:Box::new(lhs), op, rhs: Box::new(rhs)},
        span: Span {end,start}
    },
    Term
}

ElValue:ElementValue = {
    <start:@L> <id: Identifier> COLON <expr: Expression> <end: @R>=> ElementValue::Assign{prop_name: id, rhs: expr, span: Span {end,start}},
    <start: @L> <id: Type> LBRACE <values: ElValue*> RBRACE <end:@R> => ElementValue::Element(ElementExpression {name:id, values, span: Span{end,start}}),
};

ElementExpr: ElementExpression = <start:@L> <id: Type> LBRACE <values:ElValue*> RBRACE <end:@R> => ElementExpression {
    name: id,
    values:values,
    span: Span {end,start}
};

Term: ASTExpression = {
    <start:@L> <primitive: Primitive> <end: @R> => ASTExpression {
        kind: primitive,
        span: Span {end,start}
    },
    "(" <expr:Expression> ")" => expr
};

Primitive: ASTExpressionKind = {
    NumLit => ASTExpressionKind::IntLiteral(<>),
    FloatLit => ASTExpressionKind::FloatLiteral(<>),
    Identifier => ASTExpressionKind::Identifier(<>),
    ElementExpr => ASTExpressionKind::Element(<>),
    <unsigned:"u"?>LBRACE <first:Expression> COMMA <second:Expression> <rest:(COMMA Expression COMMA Expression)?> RBRACE => {
        if let Some((_,third, _, fourth)) = rest {
            if unsigned.is_some(){
                ASTExpressionKind::Uint8x4Literal(Box::new(first),Box::new(second),Box::new(third),Box::new(fourth))
            }else{
                ASTExpressionKind::Int8x4Literal(Box::new(first),Box::new(second),Box::new(third),Box::new(fourth))
            }
        }else {
            if unsigned.is_some(){
                ASTExpressionKind::Uint16x2Literal(Box::new(first),Box::new(second))
            }else{
                ASTExpressionKind::Int16x2Literal(Box::new(first),Box::new(second))
            }
        }
    }
};

pub PropertyMod:PropertyModifier = {

    PUB => PropertyModifier::Public,
    PUB LPAREN "children" RPAREN => PropertyModifier::ChildrenPublic,
    PUB LPAREN "parent" RPAREN => PropertyModifier::ParentPublic,
    => PropertyModifier::Private,
}

pub Type: GenericIdentifier = {    
    <start:@L> <name:Identifier> <gener:(LT Type GT)?> <end:@R> => GenericIdentifier {
        identifier: name,
        generic: gener.map(|(_, generic, _)| Box::new(generic)),
        span: Span {
            start,end
        }
    }
}

ComponentDeffinition:ElementDeffinition = {
    <start:@L> <modifier: PropertyMod> PROP CHILDREN SEMI <end:@R> => ElementDeffinition{
        kind:ElementDeffinitionKind::Property {
            modifier,
            name: "children".to_string(),
            ty: Some(GenericIdentifier {
                identifier: "Vector".to_string(),
                generic: Some(Box::new(GenericIdentifier {
                    identifier: "Component".to_string(),
                    generic: None,
                    span: Span {start:end.clone(),end:end.clone()}
                })),
                span: Span {start:end.clone(), end:end.clone()}
            }),
            rhs: None
        },
        span: Span {start,end}
    },
    
    <start:@L> <modifier: PropertyMod> PROP <id:Identifier> <gener:(COLON Type)?> <rhs: (EQ Expression)?> SEMI <end:@R> => ElementDeffinition{
        kind: ElementDeffinitionKind::Property {
            modifier: modifier,
            name: id,
            ty: gener.map(|(_, ty)| ty),
            rhs: rhs.map(|(_, expr)| expr),
        },
        span: Span{start,end}
    },
    <start:@L> <child:ElementExpr> <end:@R> => ElementDeffinition {
        kind:ElementDeffinitionKind::Child(child),
        span: Span {start,end}
    }
};

TypedName:TypedName = <start:@L> <name:Identifier> COLON <ty: Type> <end:@R> => TypedName {name, kind:ty, span:Span {start,end}};
TypedNames: Vec<TypedName> = {(<TypedName> COMMA)*};

pub ComponentDeclaration:ASTDeclaration = {
    <start:@L> COMPONENT <id: Identifier> LBRACE <defs: ComponentDeffinition*> RBRACE <end: @R> => {
        ASTDeclaration {
            kind: ASTDeclarationKind::ElementDeclaration {
                name: id,
                deffinitions: defs
            },
            span: Span {end,start}
        }
    }    
};

Statment:ASTStatment = {
    <start:@L> VAR <name:Identifier> <tyopt: (COLON Type)?> EQ <rhs:Expression> <end:@R> => ASTStatment {
        kind: ASTStatmentKind::Var {
            name,
            rhs,
            ty: tyopt.map(|(_, gener)| gener)
        },
        span: Span {end,start}
    },
    
    <start:@L> VAR MUT <name:Identifier> <tyopt: (COLON Type)?> EQ <rhs:Expression> <end:@R> => ASTStatment {
        kind:ASTStatmentKind::MutableVar {
            name,
            rhs,
            ty: tyopt.map(|(_, gener)| gener)
        },
        span: Span{end,start}
    },
    <start:@L> <expr:Expression> <end:@R> => ASTStatment{
        kind:ASTStatmentKind::Expression(expr),
        span: Span{end,start}
    }
};

FunctionBody: Vec<ASTStatment> = {
    <mut stmts:(<Statment> ";")*> <expr:Expression?> => {
        if let Some(expr) = expr {
            stmts.push(ASTStatment {
                span: expr.span.clone(),
                kind: ASTStatmentKind::Expression(expr),
            });
        };
        stmts
    }
};

FunctionDeclaration:ASTDeclaration = {
    <start:@L> FUNC <name:Identifier> LPAREN <args:TypedNames> RPAREN COLON <ret: Type?> LBRACE <body: FunctionBody> RBRACE <end:@R> => ASTDeclaration{
        kind: ASTDeclarationKind::FuncDeclaration {
            name, args, return_type: ret.unwrap_or(GenericIdentifier {
                identifier: "void".to_string(),
                generic: None,
                span: Span {start:0, end:0},
            }), body
        },
        span: Span{end,start}
    }
};
TopLevelDeclaration:ASTDeclaration = {
    FunctionDeclaration,
    ComponentDeclaration
};

pub Program: Vec<ASTDeclaration> = <value:TopLevelDeclaration*> => value;
